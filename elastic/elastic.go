package elastic

import (
	"bytes"
	"context"
	"encoding/json"
	"go-etl/data"
	"go-etl/helpers"
	"go-etl/logging"
	"log"
	"os"
	"sync/atomic"
	"time"

	"github.com/elastic/go-elasticsearch/v9"
	"github.com/elastic/go-elasticsearch/v9/esutil"
)

var logger = logging.GetLogger()

type StopLocation struct {
	Lat float64 `json:"lat"`
	Lon float64 `json:"lon"`
}

type IndexDocument struct {
	data.EnrichedStopTimeUpdate
	Route        helpers.RouteCSV        `json:"route"`
	TripEnriched helpers.TripCSV         `json:"trip_enriched"`
	Trip         *helpers.TripDescriptor `json:"trip"`
	StopLocation StopLocation            `json:"stop_location"`
	Timestamp    string                  `json:"@timestamp"`
}

func initClient() *elasticsearch.TypedClient {

	es_host := os.Getenv("ELASTIC_HOST")
	es_api_key := os.Getenv("ELASTIC_API_KEY")

	if es_host == "" && es_api_key == "" {
		logger.Error("Elastic credentials (ELASTIC_HOST, ELASTIC_API_KEY) not found in environment variables")
		os.Exit(1)
	}

	client, err := elasticsearch.NewTypedClient(elasticsearch.Config{
		Addresses: []string{
			es_host,
		},
		APIKey: es_api_key,
	})

	if err != nil {
		panic(err)
	}

	return client
}

func initBulkIndexer() esutil.BulkIndexer {
	client := initClient()

	es_index := os.Getenv("ELASTIC_TARGET_INDEX")

	if es_index == "" {
		logger.Error("Elastic (ELASTIC_TARGET_INDEX) target index not found in environment variables")
		os.Exit(1)
	}

	bulkIndexer, err := esutil.NewBulkIndexer(esutil.BulkIndexerConfig{
		Client:     client,
		Index:      es_index,
		NumWorkers: 4,
		FlushBytes: 5e+6,
	})

	if err != nil {
		logger.Error("Error creating the bulk indexer", "error", err)
		os.Exit(1)
	}

	return bulkIndexer
}

func IndexDocuments(documents []data.EnrichedFeedEntity) error {
	bulkIndexer := initBulkIndexer()

	var countSuccessful uint64

	now := time.Now()

	for _, trip_update := range documents {
		for _, stu := range trip_update.EnrichedTripUpdate.EnrichedStopTimeUpdates {

			doc := IndexDocument{
				EnrichedStopTimeUpdate: stu,
				Route:                  trip_update.EnrichedTripUpdate.EnrichedRoute,
				TripEnriched:           trip_update.EnrichedTripUpdate.EnrichedTrip,
				Trip:                   trip_update.TripUpdate.Trip,
				Timestamp:              time.Now().UTC().Format(time.RFC3339),
				StopLocation: StopLocation{
					Lat: stu.Stop.Lat,
					Lon: stu.Stop.Lon,
				},
			}

			data, err := json.Marshal(doc)

			if err != nil {
				return err
			}

			err = bulkIndexer.Add(
				context.Background(),
				esutil.BulkIndexerItem{
					Action:     "create",
					DocumentID: "", // Generated by ES
					Body:       bytes.NewReader(data),
					OnSuccess: func(ctx context.Context, item esutil.BulkIndexerItem, res esutil.BulkIndexerResponseItem) {
						atomic.AddUint64(&countSuccessful, 1)
					},

					// if failed
					OnFailure: func(ctx context.Context, item esutil.BulkIndexerItem, res esutil.BulkIndexerResponseItem, err error) {
						if err != nil {
							log.Printf("ERROR: %s", err)
						} else {
							log.Printf("ERROR: %s: %s", res.Error.Type, res.Error.Reason)
						}
					},
				},
			)

			if err != nil {
				return err
			}
		}
	}

	err := bulkIndexer.Close(context.Background())
	if err != nil {
		return err
	}

	stats := bulkIndexer.Stats()

	logger.Info("Successfully indexed documents", "count", countSuccessful, "duration", time.Since(now))
	logger.Info("Bulk Indexer Stats", "num_failed", stats.NumFailed, "num_indexed", stats.NumIndexed, "num_created", stats.NumCreated)

	return nil
}
